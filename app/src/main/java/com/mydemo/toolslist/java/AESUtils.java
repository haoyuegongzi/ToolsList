package com.mydemo.toolslist.java;

import android.os.Build;
import android.util.Base64;
import android.util.Log;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.json.JSONObject;

import java.security.AlgorithmParameters;
import java.security.Security;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import androidx.annotation.RequiresApi;

/**
 * @author: Nixon
 * @ProjectName: CashierSmsAndroid
 * @Package: com.lattice.goldhost.utils
 * @ClassName: AESUtils
 * @CreateDate: 2020/9/16 19:45
 * @Description: 本类作用描述：加密/解密工具类
 * @UpdateUser: 更新者：
 * @UpdateRemark: 更新说明：
 */
public class AESUtils {
    private static final String CHARSET = "UTF-8";
    /**
     * 加密
     * @param content：待加密字符串
     * @param key：秘钥
     * @return
     */
    public static String encrypt(String content, String key) {
        try {
            if (null == key || key.length() != 16) {
                throw new IllegalArgumentException("AES private key size is not 16.");
            }
            byte[] dataByte = content.getBytes();
            byte[] keyByte = key.getBytes();
            byte[] ivByte = key.getBytes();

            String encryptedData = null;
            Security.addProvider(new BouncyCastleProvider());
            //指定算法，模式，填充方式，创建一个Cipher
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding", "BC");

            //生产key对象
            SecretKeySpec secretKeySpec = new SecretKeySpec(keyByte, "AES");

            //把向量初始化到算法参数
            AlgorithmParameters params = AlgorithmParameters.getInstance("AES");
            params.init(new IvParameterSpec(ivByte));

            //指定用途，秘钥，参数 初始化Cipher对象
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, params);

            //指定加密
            byte[] result = cipher.doFinal(dataByte);

            //对结果进行Base64编码，否则会得到一串乱码，不便于后续操作
            encryptedData = Base64.encodeToString(result, Base64.DEFAULT);

            return encryptedData;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * 解密
     * @param encrypt：待解密字符串
     * @param key：秘钥
     * @return
     */
    @RequiresApi(api = Build.VERSION_CODES.O)
    public static String decrypt(String encrypt, String key) {
        try {
            if (null == key || key.length() != 16) {
                throw new IllegalArgumentException("AES private key size is not 16.");

            }
            //解密之前先把Base64格式的数据转成原始格式
            byte[] dataByte = Base64.decode(encrypt, Base64.DEFAULT);
            byte[] keyByte = key.getBytes();
            byte[] ivByte = key.getBytes();

            String data = null;

            Security.addProvider(new BouncyCastleProvider());
            //指定算法，模式，填充方式，创建一个Cipher实例
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding", "BC");

            //生产key对象
            SecretKeySpec secretKeySpec = new SecretKeySpec(keyByte, "AES");

            //把向量初始化到算法参数
            AlgorithmParameters params = AlgorithmParameters.getInstance("AES");
            params.init(new IvParameterSpec(ivByte));

            //指定用途，秘钥，参数 初始化Cipher对象
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, params);

            //执行解密
            byte[] result = cipher.doFinal(dataByte);

            //解密后转成字符串
            data = new String(result);
            return data;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static Boolean result(String decryptStr) {
        try {
            JSONObject result = new JSONObject(decryptStr);
            Log.e("TAGTAG", "run: " + result.toString());
            return result.optInt("ret", 1) == 0;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    public static void main(String[] args) {
        String key = "WLMjHQ7RAOqpzztV";
        String content = "八式往复入轮回，自生而灭为天葬";
        String encryptedContent = encrypt(content, key);
        System.out.printf("加密后的结果：" + encryptedContent);































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































        String decryptedContent = decrypt(encryptedContent, key);
        System.out.printf("\n解密后的信息：" + decryptedContent);
    }
}
